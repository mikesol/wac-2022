% This is "sig-alternate.tex" V2.1 April 2013
% This file should be compiled with V2.8 of "sig-alternate.cls" May 2012
%
% This example file demonstrates the use of the 'sig-alternate.cls'
% V2.8 LaTeX2e document class file. It is for those submitting
% articles to ACM Conference Proceedings WHO DO NOT WISH TO
% STRICTLY ADHERE TO THE SIGS (PUBS-BOARD-ENDORSED) STYLE.
% The 'sig-alternate.cls' file will produce a similar-looking,
% albeit, 'tighter' paper resulting in, invariably, fewer pages.
%
% ----------------------------------------------------------------------------------------------------------------
% This .tex file (and associated .cls V2.8) produces:
%       1) The Permission Statement
%       2) The Conference (location) Info information
%       3) The Copyright Line with ACM data
%       4) NO page numbers
%
% as against the acm_proc_article-sp.cls file which
% DOES NOT produce 1) thru' 3) above.
%
% Using 'sig-alternate.cls' you have control, however, from within
% the source .tex file, over both the CopyrightYear
% (defaulted to 200X) and the ACM Copyright Data
% (defaulted to X-XXXXX-XX-X/XX/XX).
% e.g.
% \CopyrightYear{2007} will cause 2007 to appear in the copyright line.
% \crdata{0-12345-67-8/90/12} will cause 0-12345-67-8/90/12 to appear in the copyright line.
%
% ---------------------------------------------------------------------------------------------------------------
% This .tex source is an example which *does* use
% the .bib file (from which the .bbl file % is produced).
% REMEMBER HOWEVER: After having produced the .bbl file,
% and prior to final submission, you *NEED* to 'insert'
% your .bbl file into your source .tex file so as to provide
% ONE 'self-contained' source file.
%
% ================= IF YOU HAVE QUESTIONS =======================
% Questions regarding the SIGS styles, SIGS policies and
% procedures, Conferences etc. should be sent to
% Adrienne Griscti (griscti@acm.org)
%
% Technical questions _only_ to
% Gerald Murray (murray@hq.acm.org)
% ===============================================================
%
% For tracking purposes - this is V2.0 - May 2012

\documentclass{sig-alternate}

\setlength{\paperheight}{11in}
\setlength{\paperwidth}{8.5in}
\usepackage[
  pass,% keep layout unchanged
  % showframe,% show the layout
]{geometry}

\begin{document}

% Copyright
\setcopyright{waclicense}


%% DOI
%\doi{10.475/123_4}
%
%% ISBN
%\isbn{123-4567-24-567/08/06}
%
%%Conference
\conferenceinfo{Web Audio Conference WAC-2022,}{December 6--8, 2022, Cannes, France.}
\CopyrightYear{2022} % Allows default copyright year (20XX) to be over-ridden - IF NEED BE.
%\crdata{0-12345-67-8/90/01}  % Allows default copyright data (0-89791-88-6/97/05) to be over-ridden - IF NEED BE.
% --- End of Author Metadata ---

\title{Latex Template for WAC 2022}
%\subtitle{[Extended Abstract]
%\titlenote{A full version of this paper is available as
%\textit{Author's Guide to Preparing ACM SIG Proceedings Using
%\LaTeX$2_\epsilon$\ and BibTeX} at
%\texttt{www.acm.org/eaddress.htm}}}
%
% You need the command \numberofauthors to handle the 'placement
% and alignment' of the authors beneath the title.
%
% For aesthetic reasons, we recommend 'three authors at a time'
% i.e. three 'name/affiliation blocks' be placed beneath the title.
%
% NOTE: You are NOT restricted in how many 'rows' of
% "name/affiliations" may appear. We just ask that you restrict
% the number of 'columns' to three.
%
% Because of the available 'opening page real-estate'
% we ask you to refrain from putting more than six authors
% (two rows with three columns) beneath the article title.
% More than six makes the first-page appear very cluttered indeed.
%
% Use the \alignauthor commands to handle the names
% and affiliations for an 'aesthetic maximum' of six authors.
% Add names, affiliations, addresses for
% the seventh etc. author(s) as the argument for the
% \additionalauthors command.
% These 'additional authors' will be output/set for you
% without further effort on your part as the last section in
% the body of your article BEFORE References or any Appendices.

\numberofauthors{1} %  in this sample file, there are a *total*
% of EIGHT authors. SIX appear on the 'first-page' (for formatting
% reasons) and the remaining two appear in the \additionalauthors section.
%
\author{
% You can go ahead and credit any number of authors here,
% e.g. one 'row of three' or two rows (consisting of one row of three
% and a second row of one, two or three).
%
% The command \alignauthor (no curly braces needed) should
% precede each author name, affiliation/snail-mail address and
% e-mail address. Additionally, tag each line of
% affiliation/address with \affaddr, and tag the
% e-mail address with \email.
%
% 1st. author
\alignauthor
       \name{Mike Solomon}
       \affaddr{Hyrule Project}
       \email{mike120982@gmail.com}
}
% There's nothing stopping you putting the seventh, eighth, etc.
% author on the opening page (as the 'third row') but we ask,
% for aesthetic reasons that you place these 'additional authors'
% in the \additional authors block, viz.

\date{28 June 2022}
% Just remember to make sure that the TOTAL number of authors
% is the number that will appear on the first page PLUS the
% number that will appear in the \additionalauthors section.

\maketitle
\begin{sloppypar}
\begin{abstract}
The static DOM, or SDOM, approach to building web
frameworks was first articulated by Phil Freeman[3] as an alternative to the virtual DOM, or VDOM[8], approach used
by frameworks like ReactJS[11] and Vue[13]. Since then,
several projects, most notably SolidJS[2], have developed
SDOM and related ideas into industry-grade web frameworks.
This paper explores the applicability of the SDOM approach to Web Audio. It starts by defining the main concepts behind SDOM, including functional reactive programming[12] (FRP) and the incremental lambda calculus[1].
It then discusses some of the unique challenges in porting SDOM to Web Audio, including one-to-many relationships, feedback loops, referential transparency, and live-coding. After proposing solutions to these problems, it
presents benchmarks of the SDOM-based approach compared to ToneJS, an imperative library for web audio.
\end{abstract}


%
% The code below should be generated by the tool at
% http://dl.acm.org/ccs.cfm
% Please copy and paste the code instead of the example below.
%
%\begin{CCSXML}
%<ccs2012>
 %<concept>
  %<concept_id>10010520.10010553.10010562</concept_id>
  %<concept_desc>Computer systems organization~Embedded systems</concept_desc>
  %<concept_significance>500</concept_significance>
 %</concept>
 %<concept>
  %<concept_id>10010520.10010575.10010755</concept_id>
  %<concept_desc>Computer systems organization~Redundancy</concept_desc>
  %<concept_significance>300</concept_significance>
 %</concept>
 %<concept>
  %<concept_id>10010520.10010553.10010554</concept_id>
  %<concept_desc>Computer systems organization~Robotics</concept_desc>
  %<concept_significance>100</concept_significance>
 %</concept>
 %<concept>
  %<concept_id>10003033.10003083.10003095</concept_id>
  %<concept_desc>Networks~Network reliability</concept_desc>
  %<concept_significance>100</concept_significance>
 %</concept>
%</ccs2012>
%\end{CCSXML}
%
%\ccsdesc[500]{Computer systems organization~Embedded systems}
%\ccsdesc[300]{Computer systems organization~Redundancy}
%\ccsdesc{Computer systems organization~Robotics}
%\ccsdesc[100]{Networks~Network reliability}
%
%
%%
%% End generated code
%%
%
%%
%%  Use this command to print the description
%%
%\printccsdesc
%
%% We no longer use \terms command
%%\terms{Theory}
%
%\keywords{ACM proceedings, \LaTeX, text tagging}

\section{Introduction}
Since the creation of AngularJS[4] in 2010, web frameworks have attempted with varying degrees of success to
provide a declarative, performant, and reactive approach to
building web applications. These three goals are each tradeoffs with respect to each other, and frameworks that excel in two must find novel solutions to achieve the third.
\begin{itemize}
\item The most declarative and performant structure possible is immutable HTML, which is by definition not reactive.
\item Declarative and reactive applications use a virtual
DOM, or ``VDOM'', which has poor performance as
it requires frequent diffing over large data structures.
\item Performant and reactive applications tend to funnel
information to a web app directly from event listeners,
which is naturally fragmented and resists the declarative style.
\end{itemize}

In 2018, Phil Freeman, the creator of the PureScript language, proposed a new approach to building web applications that started from the declarative+performant position and attempted to bring its reactivity in line with declarative+reactive frameworks like React and Vue. This approach is known as the static DOM, or SDOM, approach[3].
The motivating insight behind the SDOM approach is that
most websites' structures change infrequently, if at all. Freeman writes:

\begin{quote}
Denotationally speaking, the virtual DOM is
very appealing, but operationally, it is a heavyweight solution for many problems. Every time
we modify our application state and rerun our
render function, we allocate a new tree of (virtual) DOM components, and perform a tree diff
in order to discover what must change in the actual DOM. For many (most?) applications, this
seems to be overkill. We can optimize the diff algorithm in various ways, but ultimately, the diffing is essentially unnecessary --- for simple changes
to the model, I know precisely which nodes need
to be updated. We simply need a way to make
this obvious in the code.
\end{quote}

He goes on to argue that layout primitives of CSS3 such
as display, flex and grid make it possible to build a web
application where all of the nodes are rendered during an
initial render, and they are displayed and moved based on
user interactions. Even dynamic structures like lists can, to
an extent, be modeled by rendering a reasonable upper limit
of elements and then displaying or hiding them as necessary.
For applications that fall into this category, he proposes the
SDOM method.

\subsection{Defining SDOM}
The SDOM approach is one where each element of a DOM
is subscribed to an event listener, and values are broadcast
to the events in order to change the elements' attributes.
For example, in the DOM snippet below:

\begin{verbatim}
<div style="background-color: red;">
  <h1 id="hi">Hello</h1>
  <p>The SDOM is:</p>
  <ul>
    <li style="margin:3px;">Dynamic</li>
    <li>Performant</li>
    <li>Reactive</li>
  </ul>
</div>
\end{verbatim}

The DOM elements (the section, \texttt{h1}, \texttt{p}, \texttt{ul}, and three \texttt{li}-s) never change. Each attribute that is present, such as the
style of the section and list item or the id of the header,
is subscribed to an event listener and updates when a new
event fires.

\subsection{SDOM in the declarative / performant /
reactive trifecta}

The next three sections will explore how the SDOM fares
as a declarative, performant and reactive framework for
building web apps.

\subsubsection{Declarative}
By keeping the DOM static, one is able to declare its
content once. This means that no intermediary representations are needed for diffng, which allows one to use what
is called a final encoding. In final encodings, functions are
used to immediately transform input into its final representation without passing through an intermediary algebraic
data type, or ADT. In many cases, this means that a rendering engine can simply accept a string with HTML inside
of it and use it to set the innerHTML property of a DOM
Node.

\subsubsection{Performant}
Because the declarative content of the SDOM is rendered
once using a final encoding, it is extremely efficient: it avoids
the needless allocation of resources used in an intermediary representation. When using strings for innerHTML, the
browser can often parse and render a DOM string with submillisecond performance. These strings can be verified for
correctness at compile time using a tool like the webpack
JSX compiler or type-level string validation in languages
like Haskell, Idris and PureScript.
Furthermore, as the rendering only happens once upon initial render, changes to the DOM have do not require diffng
or re-rendering nodes themselves, which leads to significant
performance gains over VDOM frameworks like React.

\subsubsection{Reactive}

SDOM web apps that follow Freeman's original design are
reactive with the major caveat that the nodes themselves
cannot change (we will loosen this restriction later when discussing incremental functions). The individual nodes, then,
are subscribed to event listeners, which funnel DOM events
like clicks and timers down to the nodes.
The restriction that the DOM must be static is what allows this event-based approach to work. Without a static
DOM, elements could be removed and added at-will, and
there would be no certainty that an event would reach its
destination. This would make web apps very extremely fragile, as the presence or absence of nodes could not be guaranteed. For example, an NFT service that relies on the delivery
of a digital asset to a buyer could not be certain that the
node in which the asset is displayed is actually present. The
static nature of the DOM solves this problem

\subsection{Functional reactive programming}

When implemented poorly, the SDOM approach has the
potential to inherit the same performance limitations of
VDOM: instead of traversing a large arboreal data structure to construct a diff, one winds up traversing a large arboreal data structure to dispatch an event to all of the nodes
that may need it. Functional reactive programming[12], or FRP, is a way to solve this problem. By performing automatic memoization and providing map-reduce algorithms
for time-series data, functional reactive programming eliminates redundant computations. There is an emerging body
of literature on functional-reactive programming as applied
to web programming, audio and specifically Web Audio[9]
to which the reader can refer for more definitions of fundamental FRP primitives.

Another important aspect of FRP is its ability to preserve
state. It can do this in three ways:
\begin{itemize}
\item The Behavior type can be used by an event to poll
the state of an external entity, like a random-number
generator or whether report, when the event is fired.
\item The fold operation can be used to update an initial
state whenever an event is fired. This is the cornerstone operation of The Elm Architecture.
\item The fix combinator is used to feed event data back
into itself. When done properly, fix can be used to
model differential equations and debouncing.
\end{itemize}
Because state can be added ad-hoc at any point in the
event chain, it adds a powerful mechanism to localize state
to only the nodes in an SDOM that need it.

\subsection{Incremental functions}
The most severe limitation of the SDOM approach is its
handling of dynamic content. There are two cases where
this is particularly problematic:

\begin{itemize}
\item For some services, it is impractical or inefficient to allocate an upper-bound of resources. Event with techniques like DOM recycling for infinite scroll, a large
DOM tree can cause low-end mobile devices to perform
poorly, even when very few elements are updated.
\item Some content, such as that produced by markdown
parsers, can only be denoted in terms of recursive combinators. This includes:
\begin{itemize}
\item lists
\item \begin{itemize}
  \item within lists.
\end{itemize}
\end{itemize}
\end{itemize}
This requires the layout framework itself to be Turing complete, which cannot be achieved by the SDOM
approach as presented thus far.
One solution to this problem is the incremental lambda
calculus[1], which requires functions to be expressed as a series of diffs applied to a base data structure. For example,
when working with a HashMap, the primitives of the incremental lambda calculus only allow inserting, deleting and
modifying elements at indices, but one does not have access
to the map as a whole. Incremental approaches have proved
effective in modeling dynamic structures in otherwise immutable systems, such as mapping-s in Ethereum's Solidity
language.
Applying the incremental lambda calculus to SDOM, one
can use an indexed hash map to create and destroy internal SDOMs that have their own event logic and subscribers.
This adds the overhead of keeping track of what indices are present and which ones are absent, but this can be accomplished by the fold and fix primitives mentioned in the last
section and can be accomplished in \textit{O(1)} amortized time
when using an efficient hash map implementation.

\subsection{SDOM in industry}

The SDOM approach was first articulated by Phil Freeman in 2018. Separate from Freeman's work, the first
industry-grade SDOM framework, SolidJS[2], began in late
2018 and, as of the writing of this article in April 2022, is
the most popular and one of the most performant SDOM
frameworks. Other frameworks that occupy the declarative+performant area of the web-framework trifecta, like
Svelte and Hugo, have incorporated ideas from the SDOM
approach into their implementations as well.

\section{SDOM and Web Audio}

At first glance, the SDOM approach seems ideally suited
to web audio. Audio graphs change relatively infrequently,
their nodes respond to events, and the nodes themselves
are not referentially transparent. In applications that need
dynamic and recursively-defined content, incremental functions over indexed structures can be used to update the audio graph. However, there are four main issues that exist in
web audio that are not addressed by the SDOM approach:

\begin{itemize}
\item One-to-many relationships.
\item Feedback loops.
\item Leaking referentially-opaque nodes.
\item Live-coding and other dynamic arts.
\end{itemize}
The following section proposes solutions to all four issues.
It does so in JavaScript pseudocode, occasionally employing
TypeScript-esque syntax when explicit types are necessary.

\subsection{One-to-many relationships}

In the DOM, a node can only ever have one parent. In Web Audio, however, a node can be connected to many outgoing
nodes as an audio or control signal. One way to articulate
this relationship in the SDOM style is to use a fan operation
that injects an opaque blob into a closure where it can be
used 0 or more times.

\begin{verbatim}
var node =
  fan(sawtoothOsc(440.0), (osc) =>
    gain(bandpass(1000.0, osc)
        , highpass(3000.0, osc)))
\end{verbatim}

In the example above, osc is injected into the function
at the moment of interpretation. This makes it possible
to use in a purely-functional context that expects referential
transparency: as there is no way to construct the node aside
from its opaque representation, it is the equivalent of a unary
constructor like Unit in Haskell, Scala and PureScript.

\subsection{Feedback}

Feedback in an SDOM Web Audio representation can be
handled in the same manner that it is in FRP: via a fixedpoint combinator.
\begin{verbatim}
var node =
  fix((node) =>
    gain(sinOsc(440.0)
      , highpass(1000.0, delay(0.2, node))))
\end{verbatim}
As with fan, fix is an opaque blob that is provided by the
interpreting library at the moment of function evaluation.
An issue arises in attributing unique IDs to the
recursively-defined node, as the ID attributed to the return
value will also have to be attributed to the input node.
This is a classic problem when working with De Bruijn
indices, and it can be solved by a deferred naming strategy: if an audio node in the underlying engine is defined as
(id) => node, then the same ID can be given to the input
and output nodes once the function has been evaluated.
\begin{verbatim}
var fix = (f) => {
  var id = Math.random();
  var i = mkNode(id);
  var out = f(i);
  return out(id);
}
\end{verbatim}
A problem still exists with the connecting of nodes in a
final encoding, as certain nodes will not yet be created at
the moment of connection, but it is possible for the final
encoding to defer the connection of nodes until both ends of
the connection have been created.

\subsection{Referential transparency}

Up until now, we have avoided running into issues of referential transparency because the only values that are not
referentially transparent in our SDOM Web Audio implementation, namely the inputs to fan and fix, are singletons,
which along with nullary values (ie Void in Haskell) have
identical representations in opaque and transparent context,
as they can only be substituted for themselves.

This issue is problematic, however, for nodes that
emit events, such as AudioBufferSourceNode and
OscillatorNode, both of which emit an ended event.
Imagine the following scenario:

\begin{verbatim}
var node =
  fix((node) =>
    gain(sinOsc(myFreq
      , ended(() => push(node)()))));
\end{verbatim}

In the sinOsc's event listener for the ended event, we have
now pushed a referentially opaque reference to a gain node.
This reference can be consumed by any event subscription
and can be used, for example, in another audio graph's definition. As the other audio graph belongs to a different
context, it would break at the moment of instantiation.

The solution to this problem is to use existential typing to ``lock'' nodes into a context. Existential types[7], or
rank-N types, are a zero-cost abstraction that establishes a
closed computational context in strongly-typed languages.
In dynamically-typed languages like JavaScript this is impossible, so we'll use TypeScript pseudocode to express this
idea.

\begin{verbatim}
type Node<A> = {
  id: number;
}
type Run =
  (node: <A>( : Node<A>) => Audio)
    => Audio
\end{verbatim}

Now, all nodes passed to Run must be polymorphic over a
phantom type A, which means that it cannot be specialized:
it needs to remain universally quantified. Trying to pass in
a node from another context will not work because it will,
by definition, be specialized to the scope of the universal
quantifier from another context. This is also called a Skolem
variable escaping its scope and occurs when a quantified
variable from a statement in Skolem-normal form[5] is used
in another statement. For example, if you say ``All Z like
treats'' and ``All Z like to play'' and agree that Z is not a
concrete type but a variable to be determined later, the two
Z's cannot be mutually interchanged because their scopes
are different and they could wind up being instantiated with
different entities.

This technique of using existential quantification to create
a closed computational context is most commonly used in
the ST monad from Haskell[10] and PureScript, which uses
a similar approach to create type-safe mutable references.

\subsection{Live coding}

As mentioned before, incremental functions provide a way
to inject dynamic behavior into an SDOM approach, and the
same technique can be used for an SDOM-ified Web Audio.
However, the functions fan and fix result in a situation
where the nodes used therein are hermetically sealed within
their closures. That means that if, for example, one is performing a live-coding set, it is impossible to connect a node
from closure A to closure B, whereas in an imperative-style
language like SuperCollider this is not a problem.

The solution to this problem is to create a referentially
opaque node that is itself an event and to attach a selfEvent
to every node that, when triggered, pushes a reference to the
node to enclosing event. Every time a new node is supplied
to the event, the previous node (if there was one) is disconnected and the new node is connected.

\begin{verbatim}
var node =
  event((node, push) =>
    gain(sinOsc(440.0
      , selfEvent(push)
      , ended(() => push(node)))));
\end{verbatim}

\section{Benchmarks}
To benchmark the SDOM approach to Web Audio, I used
purescript-ocarina, a PureScript Web Audio library designed
using SDOM principles, and ToneJS[6]. ToneJS occupies
the performant+reactive part of the DOM trifecta at the
expense of not being declarative.

\subsection{Benchmark design}
As ocarina's design decisions occupy the declarative+performant part of the design space and uses
the SDOM design pattern to achieve high reactivity, it was
important to design a highly reactive experiment. As such,
in this experiment, I created an event every 0.25 seconds
that triggered 90 reactive events (turning on an oscillator,
triggering an ADSR envelope, and turning off an oscillator)
in both frameworks to stress test reactivity.

\subsection{Tone.js}
\begin{verbatim}
const n = 30;
const gainNodes =
  Array.from(Array(n).keys())
   .map(()=>newTone.Gain(0.002)
  .toDestination());
const oscs=
  Array.from(Array(n).keys())
   .map((i)=>
     newTone.Oscillator(440.0+i*80)
      .connect(gainNodes[i]));
Tone.Transport.scheduleRepeat((time)=>{
 for(var i=0;i<n;i++) {
  oscs[i].start(time).stop(time+0.1);
 }
},"8n");
Tone.Transport.start();
\end{verbatim}
\subsection{PureScript Ocarina}
\begin{verbatim}
music time=do
let
  e0=adsr<<<add 0.03
  oon=bangOn'
  oof=bangOff'<<<add 0.22
  [gain1.0
  (map(\i->gain 0.0 (map e0 time)
  [sinOsc(toNumber i*80.0+440.0)
  (keepLatest$map(oneOf
  <$>sequence[oon,oof])time)])
  (0..29))
  ]
myIvl<-memoize
  $ interval ctx 0.25
  $ bang 0.25
run2 ctx (music myIvl)
\end{verbatim}
\subsection{Benchmark results}
The benchmarking was run 10 times over roughly 10 second intervals. Wags occupies on average 1.37
This shows that Wags, coming from a position of being
performant and declarative, is able to achieve high reactivity in a reasonable number of lines of code and excellent
performance.
\section{Conclusion}
In this article, the SDOM approach of web application
development was presented and applied to the Web Audio domain. In doing so, the article proposed solutions to
several shortcomings of the SDOM approach and provided
benchmarks against an industry leading framework, ToneJS.
Further avenues of research can explore applying this approach to the DSP graph itself as well as using nested and
recursively-defined events to create more dynamic and expressive audio graphs.
\section{Acknowledgments}
I'd like to thank Phil Freeman for his work on the \texttt{purview},
\texttt{sdom}, \texttt{event} and \texttt{behavior} libraries in the PureScript ecosystem, without which I would have never thunk the thoughts
that fueled the writing of this article.
%
% The following two commands are all you need in the
% initial runs of your .tex file to
% produce the bibliography for the citations in your paper.
\bibliographystyle{abbrv}
\bibliography{sigproc}  % sigproc.bib is the name of the Bibliography in this case
% You must have a proper ".bib" file
%  and remember to run:
% latex bibtex latex latex
% to resolve all references
%
% ACM needs 'a single self-contained file'!
%
%APPENDICES are optional
%\balancecolumns
\appendix
%Appendix A
\section{Headings in Appendices}
The rules about hierarchical headings discussed above for
the body of the article are different in the appendices.
In the \textbf{appendix} environment, the command
\textbf{section} is used to
indicate the start of each Appendix, with alphabetic order
designation (i.e. the first is A, the second B, etc.) and
a title (if you include one).  So, if you need
hierarchical structure
\textit{within} an Appendix, start with \textbf{subsection} as the
highest level. Here is an outline of the body of this
document in Appendix-appropriate form:
\subsection{Introduction}
\subsection{The Body of the Paper}
\subsubsection{Type Changes and  Special Characters}
\subsubsection{Math Equations}
\paragraph{Inline (In-text) Equations}
\paragraph{Display Equations}
\subsubsection{Citations}
\subsubsection{Tables}
\subsubsection{Figures}
\subsubsection{Theorem-like Constructs}
\subsubsection*{A Caveat for the \TeX\ Expert}
\subsection{Conclusions}
\subsection{Acknowledgments}
\subsection{Additional Authors}
This section is inserted by \LaTeX; you do not insert it.
You just add the names and information in the
\texttt{{\char'134}additionalauthors} command at the start
of the document.
\subsection{References}
Generated by bibtex from your ~.bib file.  Run latex,
then bibtex, then latex twice (to resolve references)
to create the ~.bbl file.  Insert that ~.bbl file into
the .tex source file and comment out
the command \texttt{{\char'134}thebibliography}.
% This next section command marks the start of
% Appendix B, and does not continue the present hierarchy
\section{More Help for the Hardy}
The sig-alternate.cls file itself is chock-full of succinct
and helpful comments.  If you consider yourself a moderately
experienced to expert user of \LaTeX, you may find reading
it useful but please remember not to change it.
%\balancecolumns % GM June 2007
% That's all folks!
\end{sloppypar}
\end{document}
